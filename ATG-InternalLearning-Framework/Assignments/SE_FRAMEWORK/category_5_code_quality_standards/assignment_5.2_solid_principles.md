# Assignment 5.2: SOLID Principles

## Assignment Information
- **Category**: Code Quality & Standards
- **Sub-category**: 5.2 SOLID Principles
- **Team Members**: [Pair names to be assigned]
- **Presentation Date**: [To be scheduled]
- **Duration**: 30-45 minutes

---

## Learning Objectives
By the end of this session, the team should be able to:
1. Understand and apply the Single Responsibility Principle in class design
2. Implement Open/Closed Principle for extensible code
3. Apply Liskov Substitution, Interface Segregation, and Dependency Inversion principles
4. Recognize SOLID violations and refactor code accordingly

---

## Topics to Cover

### 1. Single Responsibility Principle (SRP)
- One class, one reason to change
- Identifying responsibilities
- Separating concerns
- Practical examples and violations

### 2. Open/Closed Principle (OCP)
- Open for extension, closed for modification
- Abstraction and polymorphism
- Strategy pattern application
- Plugin architectures

### 3. Liskov Substitution Principle (LSP)
- Substitutability of derived classes
- Contract adherence
- Common violations (Rectangle/Square)
- Proper inheritance design

### 4. Interface Segregation & Dependency Inversion
- Interface Segregation: many specific interfaces over one general
- Dependency Inversion: depend on abstractions, not concretions
- Dependency injection patterns
- Inversion of Control (IoC) containers

---

## Assignment Deliverables

### 1. Presentation (20-30 minutes)
- Each SOLID principle explained with diagrams
- Real-world examples of each principle
- Common violations and how to fix them
- SOLID benefits for maintainability and testing

### 2. Code Demo/Example
- Demonstrate each SOLID principle with code
- Show violations and refactored solutions
- Implement dependency injection
- Compare SOLID vs non-SOLID designs
- Use real-world scenarios

### 3. Resources & References (Provide 3-5 curated)
- Uncle Bob's SOLID principles articles
- SOLID examples in your programming language
- Design patterns that embody SOLID
- Refactoring to SOLID guides
- Video tutorials on each principle

### 4. Q&A Session (10-15 minutes)
- Prepare for questions about SOLID in legacy code
- Over-engineering concerns
- SOLID in different paradigms (functional, OOP)
- When to relax SOLID principles
- Testing and SOLID relationship

---

## Preparation Guidelines

### Research
- Study each SOLID principle in depth
- Find language-specific examples
- Understand design patterns related to SOLID
- Review SOLID violations and refactorings

### Practice
- Refactor code to follow SOLID
- Implement each principle separately
- Create before/after examples
- Build testable code using SOLID
- Practice dependency injection

### Collaboration
- Review ATG code for SOLID compliance
- Identify SOLID violations
- Discuss refactoring opportunities
- Share SOLID success stories

### Engagement
- Interactive: identify which principle is violated
- Live refactoring to SOLID
- Group exercise: apply SOLID to scenario
- Debate: is this over-engineering?

---

## Success Criteria
- [ ] Clear understanding of all five SOLID principles
- [ ] Ability to identify SOLID violations
- [ ] Practical refactoring skills to SOLID
- [ ] Understanding of SOLID benefits and trade-offs
- [ ] Team can apply SOLID in code reviews

---

## Support & Resources
- Software Engineering Excellence Framework document
- SOLID principles documentation
- Refactoring resources
- Design patterns catalog

---

## Notes
- Foundation for design patterns (Category 6)
- Critical for maintainable code
- Connect to testing strategies (Category 7)
- Discuss how Copilot handles SOLID principles
- Emphasize pragmatism over dogmatism
- Relate to clean architecture patterns
